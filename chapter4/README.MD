# **검색과 응답을 최적화하는 RAG 고도화 전략**  
RAG 고도화 전략 워크플로우  
![img.png](image/img.png)  
  
RAG 고도화는 관련 문서를 가져오는 Retrieval 파트와 응답을 생성하는 Generation 파트 모두에서 달성할 수 있다. 각 파트에서 개선할 수 있는 주요 
구성요소와 고도화 방안을 정리하면 다음과 같다.  
  
![img.png](image/img2.png)  
  
# **청킹 전략**  
문서 전처리 단계는 RAG 시스템에서 실제 검색에 사용될 문서들을 가공하여 검색과 생성에 최적화된 형태로 변환하는 과정이다. 효과적인 전처리는 검색 정확도를 
높이고 관련성 있는 정보를 더 잘 추출할 수 있게 도우며 궁극적으로 생성 모델의 응답 품질을 향상시킨다.  
  
문서 전처리 과정은 여러 단계로 구성되는데 그중 핵심적인 단계가 청킹(chunking), 즉 문서 분할 단계다. 문서 분할은 긴 문서를 더 작고 관리하기 쉬운 
단위로 나누는 과정이다. 효과적인 분할 방식은 관련 정보의 검색 정확도를 높이고 문맥의 일관성을 유지하는 데 도움을 준다. 또한 생성 모델이 처리해야 할 
컨텍스트의 양을 적절히 조절하여 응답 생성의 품질을 향상시킬 수 있다.  
  
가장 기본적인 문서 분할 방식은 문자 수 기반 분할(character splitting)이다. 이는 문서를 단순히 일정 길이의 문자 단위로 나누는 방식으로 구현이 
간단하고 빠르다는 장점이 있다. 하지만 문장이나 단락의 의미적 구조를 고려하지 않기 때문에 중요한 정보가 분할되어 검색 시 누락되거나 문맥이 왜곡될 수 
있다는 단점이 있다. 또한 고정된 길이로 분할하기 때문에 문서의 내용과 구조에 따른 최적화가 어려울 수 있다.  
  
# **부모-자식 분할**  
재귀적 문자 텍스트 분할 방식은 문서의 구조를 고려하여 분할하지만 의미를 고려하지 않고 기계적인 규칙에 따라 텍스트를 분할하기 때문에 연관된 내용이 
분리되어 문맥이 끊길 수 있는 문제가 있다. 또한 의미 기반 분할은 텍스트의 의미적 연관성을 고려하여 일관된 청크를 생성하는 데 효과적이지만 긴 문서나 
복잡한 주제를 다룰 때 문서의 전체적인 구조와 계층적 관계를 완벽하게 포착하기에는 한계가 있다.  
  
이러한 한계를 보완하고 문서의 구조적 정보를 더 잘 활용하기 위한 방법으로 부모-자식 분할(parent-child chunking)이 있다. 이 방법은 문서의 계층 
구조를 유지하면서도 세부적인 내용까지 보존하는 접근 방식이다.  
  
부모-자식 분할은 다음과 같은 핵심 개념을 바탕으로 한다. 먼저 문서를 계층적으로 분할하여 원본 문서를 큰 단위의 부모 문서로 나누고 이를 다시 작은 단위의 
자식 문서로 세분화한다. 이렇게 원본 문서 -> 부모 문서 -> 자식 문서의 3단계 구조를 형성한다.  
  
부모-자식 분할 방식은 문서의 저장과 검색에서 이원화된 접근법을 채택한다. 문서의 계층구조를 유지하면서도 효율적인 검색을 위해 자식 문서는 벡터 
데이터베이스에 임베딩하여 저장하고 부모 문서는 별도의 저장소에 원본 형태로 보관한다. 실제 검색 시에는 자식 문서를 기반으로 유사성 검색을 수행하지만 
최종적으로 반환되는 문서는 해당 저장 문서가 속한 부모 문서다.  
  
이 방식에는 두 가지 주요 장점이 있다. 첫 번째는 정확한 정보 검색이다. 정보를 검색할 때는 자식 청크를 사용하기 때문에 질문과 관련성 높은 정보를 
정확히 찾아낼 수 있다. 자식 청크는 특정 주제에 집중된 정보를 담고 있어 질문과 정확한 매칭이 가능하다. 따라서 대량의 텍스트에서 특정 정보를 빠르고 정확하게 
식별하는 데 효과적이다.  
  
두 번째는 넓은 맥락을 제공한다는 점이다. 검색 결과로 부모 문서를 반환함으로써 특정 정보뿐만 아니라 그 정보가 포함된 전체적인 맥락까지 함께 파악할 
수 있다. 부모-자식 분할이 동작하는 자세한 과정은 다음과 같다.  
  
1. 문서 분할  
먼저 원본 문서를 비교적 큰 크기의 부모 문서로 나눈다. 이때 문서의 구조적 특성(예: 장, 절, 단락)을 고려할 수 있다. 이후 각 부모 문서를 더 작은 
자식 문서로 나눈다. 이 과정에서 의미 기반 분할같은 다른 기술을 활용할 수도 있다.  
2. 메타데이터 할당  
각 자식 문서에 해당 부모 문서의 식별자를 메타데이터로 할당한다. 이를 통해 자식 문서와 부모 문서 간의 관계를 추적할 수 있다.  
3. 임베딩 저장  
자식 문서는 벡터 데이터베이스에 저장된다. 이때 각 청크의 텍스트 내용은 임베딩되어 벡터 형태로 저장된다. 부모 문서는 별도의 문서 저장소에 저장된다.  
  
이후 부모-자식 청킹 처리된 문서의 검색 과정은 다음과 같다.  
  
1. 사용자 쿼리가 입력되면 먼저 벡터 데이터베이스에서 쿼리와 가장 유사한 자식 문서를 검색한다.  
2. 검색된 자식 문서의 메타데이터를 확인하여 해당하는 부모 문서의 식별자를 찾는다.  
3. 찾은 식별자를 이용해 문서 저장소에서 관련된 부모 문서를 반환한다.  
  
이러한 방식을 통해 부모-자식 분할은 문서의 구조적 정보를 유지하면서도 효율적인 검색과 정보 추출을 가능하게 한다. 중요한 점은 부모-자식 분할이 의미 
기반 분할을 대체하는 것이 아니라 두 기술을 상호 보완적으로 사용할 수 있다는 것이다. 예를 들어 부모 문서를 자식 문서로 나눌 때 의미 기반 분할을 적용하여 
의미적으로 더 일관된 청크를 만들 수도 있다.  
  
다음은 부모-자식 분할을 랭체인으로 구현한 코드다.  
  
PARENT_CHILD_CHUNKING.ipynb  
  
먼저 필요한 라이브러리를 설치하고 오픈AI API 키를 설정한다.  
  
이어서 분할에 사용할 문서를 로드한다. How_to_invest_money.txt 파일을 사용한다. 텍스트 파일을 사용하므로 랭체인의 TextLoader 클래스를 사용한다. 
TextLoader는 텍스트 파일을 읽어 랭체인의 Document 객체로 변환하는 클래스다.  
  
이제 부모-자식 분할에 필요한 설정을 진행한다. 재귀적 문자 텍스트 분할 방식을 활용하여 부모 문서와 자식 문서를 생성한다. 이때 부모 문서의 크기(chunk size)는 
1000으로 자식 문서의 크기는 200으로 설정함으로써 부모-자식 계층 구조를 만든다.  
  
자식 문서 저장소는 Chroma 벡터 데이터베이스를 사용한다. Chroma 인스턴스의 collection_name 파라미터를 "split_parents"로 지정하여 부모 문서와 
연관성을 유지한다.  
  
부모 문서 저장소는 InMemoryStore를 사용한다. 이는 RAM에 데이터를 저장하는 방식으로 빠른 읽기와 쓰기가 가능하지만 프로그램 종료 시 데이터가 
손실되는 특징이 있다. 이제 ParentDocumentRetriever 인스턴스를 생성한 후 실제 문서를 추가하여 문서가 성공적으로 분할되었는지 확인한다.  
  
먼저 자식 문서 저장소(vectorstore), 부모 문서 저장소(store), 자식 문서 텍스트 분할기(child_splitter), 부모 문서 텍스트 분할기(parent_splitter)를 
인자로 받는 ParentDocumentRetriever 인스턴스를 생성한다. 이를 통해 부모-자식 구조의 계층적 문서 검색을 수행할 수 있다.  
  
다음으로 retriever.add_documents(docs) 메서드를 사용하여 문서를 추가한다. 이 과정에서 문서들이 자동으로 부모와 자식 문서로 분할되어 각각의 저장소에 
저장된다. 이후 store.yield_keys()를 사용하여 저장된 모든 부모 문서의 키를 가져온 뒤 해당 키의 개수를 세어 총 부모 문서의 수를 확인하고 문서 분할과 
저장이 제대로 이루어졌는지 검증한다.  
  
코드 실행 결과로 총 219개의 부모 문서가 InMemoryStore에 저장되었다. 이는 원본 문서가 1000자 단위로 분할되어 219개의 부모 문서로 나뉘었다는 
뜻이다. 각 부모 문서는 다시 200자 단위의 자식 문서로 분할되어 Chroma 벡터 저장소에 저장되었다.  
  
이제 실제로 검색을 수행한다. "What are the types of investments?"라고 질의한다. 이 질문이 ParentDocumentRetriever를 거치면 관련된 부모 문서가 
검색된다. 첫 번쨰 연관 문서만 출력해서 확인해본다.  
  
![img.png](image/img3.png)  
  
이제 부모-자식 분할의 작동 방식을 이해하기 위해 벡터 저장소에서 직접 자식 문서를 검색해서 첫 번째 자식 문서를 출력해본다.  
  
![img.png](image/img4.png)  
  
결과를 보면 자식 문서와 부모 문서의 차이점과 각각의 역할을 명확히 확인할 수 있다. 자식 문서는 투자의 다섯 가지 주요 고려사항이라는 질문에 직접적으로 
관련된 핵심 정보를 간결하게 제공한다. 반면 부모 문서는 이 정보를 포함하면서도 해당 장에서 부동산 담보 대출에 대해 논의할 것이라는 추가적인 맥락을 
제공한다.  
  
자식 문서를 통해 질문과 가장 관련성 높은 정보를 정확히 찾아내고 부모 문서를 통해 해당 정보의 더 넓은 맥락을 제공한다. 이로써 사용자는 구체적인 정보와 
함께 정보가 속한 전체적인 맥락을 파악할 수 있게 된다.  
  
# **질의 변형**  
질의 변형(query reformation)은 사용자의 원래 질문을 보다 효과적인 검색 쿼리로 변환하는 과정을 말한다. 기본적인 RAG 검색 시스템에서는 사용자 질문을 
그대로 사용하여 관련 문서를 검색한다. 하지만 사용자의 질문이 모호하거나 검색에 최적화되지 않은 형태인 경우 연관 문서를 제대로 검색할 수 없어 RAG 
시스템의 정확도가 떨어지게 된다는 단점이 있다.  
  
질의 변형은 원래의 질문을 분석하고 재구성하여 이러한 문제를 해결한다. 이 과정에서 질문을 더 구체적이고 검색에 최적화된 형태로 재작성하거나 복잡한 질문을 
여러 개의 하위 질문으로 분해하는 등의 기법을 활용한다. 또한 질문의 의도를 파악하여 더 일반화된 쿼리로 확장하거나 가상의 문서를 생성하여 검색 성능을 
개선하는 방법도 포함된다.  
  
이러한 질의 변형 기법은 검색의 저확성과 포괄성을 크게 높여 결과적으로 RAG 시스템의 전반적인 성능 향상으로 이어진다.  
  
# **다중 질의 생성**  
다중 질의 생성(multiquery generation)은 질의 변형의 한 기법으로 사용자의 원래 질문을 바탕으로 여러 개의 다양한 쿼리를 생성하는 방법이다. 이 기법의 
동작 과정은 다음과 같다.  
  
1. 다중 질의 생성  
LLM을 사용하여 원래 질문을 다양한 관점으로 변형시킨 여러 개의 질문을 생성한다. 이 과정에서 동의어 사용, 질문 구조 변경, 특정 측면 강조 등 다양한 
기법을 적용할 수 있다.  
2. 병렬 검색  
생성된 각 쿼리를 사용하여 독립적으로 문서를 검색한다.  
3. 결과 통합  
각 쿼리로부터 얻은 검색 결과를 종합하여 중복을 제거하고 가장 관련성 높은 문서들을 선별한다.  
  
![img.png](image/img5.png)  
  
예를 들어 사용자가 주식 투자를 처음 시작하려면 어떻게 해야 하나요? 라고 질문했다면 이를 다양한 관점으로 변화시킨 다음 쿼리들을 생성할 수 있다.  
  
- 초보 투자자를 위한 투자 기초 지식은 무엇인가?  
- 주식 시장 분석을 위한 기본적인 재무제표 읽는 법은?  
- 주식 투자 시작 전 필요한 자금 관리 전략은?  
  
이들 각각의 쿼리는 독립적인 문서 검색에 사용되어 보다 다양한 문서를 수집하게 한다. 즉 기존의 단순한 주식 투자 시작 방법에 대한 정보뿐만 아니라 투자 지식, 
재무 분석, 자금 관리 방법 등 초보 투자자에게 필요한 다양한 측면의 정보를 포괄적으로 검색할 수 있게 되는 것이다. 이는 사용자가 명시적으로 언급하지 
않았지만 주식 투자를 시작하는 데 중요한 관련 주제들까지 탐색할 수 있어 더 풍부하고 실용적인 정보를 제공할 수 있다.  
  
다중 질의 생성 기법에는 여러 가지 이점이 있다. 먼저 다양한 쿼리를 생성함으로써 검색 범위를 넓혀 더 많은 관련 정보를 찾아낼 수 있다. 이는 단일 
쿼리로는 놓칠 수 있는 중요한 정보를 포착하는 데 도움이 된다. 또한 모호한 질문을 다룰 때 특히 유용하다. 하나의 질문을 여러 가지 방식으로 해석하고 
쿼리를 생성함으로써 사용자의 의도를 더 정확히 파악하고 그에 맞는 결과를 제공할 수 있기 떄문이다. 즉 사용자가 정확히 무엇을 원하는지 명확하지 않은 
상황에서도 적절한 답변을 찾는 데 도움을 줄 수 있다.  
  
다중 질의 생성을 랭체인으로 구현한 코드는 다음과 같다. 다중 질의 생성에는 오픈 AI의 gpt-4o 모델을 사용했다.  
  
MULTIQUERY_GENERATION.ipynb  
  
먼저 필요한 라이브러리를 설치하고 오픈AI API 키를 설정한다. 이어서 다중 질의 생성 과정을 모니터링하기 위한 로깅을 설정한다. 이를 활용하면 생성된 
질의들을 콘솔에서 확인할 수 있다.  
  
이제 벡터 데이터베이스와 문서 로더를 설정한 뒤 문서를 불러온다. 먼저 TextLoader를 사용하여 How_to_invest_money.txt 파일을 로드한 뒤 문서 데이터를 
가져온다.  
  
loaders 리스트에 하나의 TextLoader 인스턴스를 추가하고 docs라는 빈 리스트를 생성한다. 다음으로 for 문에서 loaders 리스트에 있는 로더의 load() 
메서드를 호출하여 각 로더로부터 로드된 문서 데이터를 docs 리스트에 추가한다.  
  
이제 문서를 분할하기 위한 텍스트 분할기와 벡터 저장소의 인스턴스를 생성한다. 먼저 RecursiveCharacterTextSplitter(재귀적 문서 분할기)를 사용해 문서를 
1000자 단위로 나누고 200자의 중복을 유지한다.  
  
문서를 분할한 후에는 OpenAIEmbeddings로 문서 데이터를 임베딩하여 Chroma 벡터 저장소에 저장하고 문서 검색과 유사도 계산에 활용한다.  
  
이제 다중 질의 생성을 위한 리트리버를 설정한다. 이 과정에서는 랭체인의 MultiQueryRetriever를 활용하여 사용자가 입력한 질의를 다양한 방식으로 변형하고 
더 정교한 검색 결과를 얻을 수 있도록 한다.  
  
먼저 대규모 언어 모델을 설정한다. 여기서는 오픈 AI의 GPT-4o 모델을 사용하는 ChatOpenAI를 사용한다. 모델 설정 시 temperature값을 0.2로 지정하여 
모델이 비교적 일관되고 신뢰성 있는 응답을 생성하도록 조정한다.  
  
다음으로 MultiQueryRetriever를 생성한다. 이 리트리버는 앞서 생성한 Chroma 벡터 저장소의 검색기를 기본 검색기로 사용하고 질의 변형을 위한 언어 
모델로 앞서 정의한 대규모 언어 모델(GPT-4o)을 사용한다.  
  
이제 실제 "주식 투자를 처름 시작하려면 어떻게 해야 하나요?"라는 질문을 한다. 질문은 invoke() 메서드를 통해 retriever 객체에 전달되어 세 가지 
다른 질문으로 변형된 뒤 벡터 데이터베이스에 전달된다.  
  
![img.png](image/img6.png)  
  
코드 실행 결과 "주식 투자를 처음 시작하려면 어떻게 해야 하나요?"라는 기존 질문이 다음과 같은 세 가지 다른 관점의 질문들로 변환되어 검색에 활용됨을 
알 수 있다.  
  
- 주식 투자 초보자가 알아야 할 기본 단계는 무엇인가요?  
- 주식 투자를 처음 시작할 때 필요한 준비 사항은 무엇인가요?  
- 주식 투자 입문자를 위한 가이드라인이나 조언이 있나요?  
  
이러한 각기 다른 세 가지 관점의 질문은 원본 질문보다 주식 투자 시작에 대한 더 폭넓은 정보를 검색할 수 있도록 한다. 이를 통해 사용자에게 더욱 풍부하고 
다양한 관점의 답변을 제공할 수 있다.  
  
이제 검색된 문서들을 활용하여 최종 답변을 생성하는 RetrievalQA 체인을 설정한다. 이 체인은 앞서 생성한 다중 질의 리트리버를 사용하여 문서를 검색하고 
검색된 문서들의 내용을 바탕으로 사용자의 질문에 대한 종합적인 답변을 생성한다.  
  
![img.png](image/img7.png)  
  
최종적으로 생성된 답변은 주식 투자를 시작하는 사람들이 알아야 할 기본 단계, 그리고 투자 전략에 대한 종합적인 정보를 제공함으로써 사용자의 질문에 더 
충실하게 응답할 수 있게 된다. 이는 RAG 시스템에서 다중 질의 전략이 검색과 응답 품질을 크게 향상시킬 수 있음을 보여준다.  
  

  

  
