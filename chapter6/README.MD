# **랭그래프로 설계하는 RAG 파이프라인**  
랭그래프(LangGraph)는 LLM 기반 에이전트 시스템을 쉽고 효율적으로 개발할 수 있도록 지원하는 라이브러리다. 여러 개의 에이전트로 구성된 LLM 애플리케이션과 
RAG 파이프라인에서 자주 사용되는 순환(loop)과 분기(branch)를 포함한 복잡한 워크플로우를 간편하게 구현할 수 있도록 다양한 기능을 제공한다.  
  
다음과 같은 예를 떠올려 보자  
- LLM을 사용하여 생성된 답변이 충분한지 혹은 답변을 재생성할지 결정한다.  
- LLM을 사용하여 어떤 툴(Tool)을 호출할지 결정한다.  
  
이처럼 순환 구조를 갖는 LLM 파이프라인 안에는 여러 분기점이 존재할 수 있으며 이러한 분기점이 많아질수록 시스템 구현은 더욱 복잡해진다. 랭그래프는 
그래프 구조를 활용해 이를 간단하게 구현할 수 있도록 도우며 다양한 제어 방식을 제공해 애플리케이션의 기능과 유연성을 한층 강화한다.  
  
# **랭그래프의 구성요소**  
먼저 그래프의 기본 개념을 짚어본다. 그래프는 객체들 간의 관계를 나타낼 때 사용하는 데이터 구조로 노드와 에지로 이루어져 있다.  
  
- 노드(Node, 정점): 그래프에서 개별 객체를 나타내는 요소이다. 예를 들어 소셜 네트워크를 그래프로 표현한다면 각 사용자가 하나의 노드가 된다.  
- 에지(Edge, 간선): 드 노드를 연결하는 요소로 노드 간의 관계 또는 경로를 나타낸다. 소셜 네트워크를 그래프로 표현한다면 사람들 사이의 친구 관계가 
에지가 된다.  
  
랭그래프에서는 이러한 그래프 구조를 이용해 다양한 워크플로우를 구현한다. 기본 동작 방식은 노드가 작업을 완료하면 하나 이상의 에지를 통해 다른 노드에게 
메시지를 보내고 메시지를 받은 노드는 자신의 기능을 실행한 후 다음 노드로 메시지를 다시 전달하는 과정을 반복하는 방식이다.  
  
# **그래프**  
랭그래프의 그래프는 구글의 프리겔(Pregel)에서 영감을 받은 슈퍼스텝(super-steps) 방식으로 동작한다. 슈퍼스텝은 그래프 처리 과정의 한 단계로 각 노드가 
병렬로 동시에 작업을 수행하는 단위다. 병렬로 작업을 수행한다는 것은 한 노드가 일을 끝낸 후에 다른 노드가 일을 시작하는 것이 아니라 여러 노드가 동시에 
자신의 일을 하는 모습을 뜻한다. 이렇게 동시에 실행되는 노드는 동일한 슈퍼스텝에 속하며 순차적으로 실행되는 노드는 별도의 슈퍼스텝에 속한다.  
  
노드는 하나 이상의 입력 에지에서 새로운 메시지(상태)를 수신할 때 활성화된다. 활성화된 노드는 자신의 기능을 실행하고 처리 결과를 다른 노드로 전달한다. 
각 슈퍼스텝이 끝날 때 입력 메시지가 없는 노드는 자신을 비활성화료 표시하여 완료된 상태로 표시한다. 모든 노드가 비활성화되고 더 이상 메시지가 
전송 중이지 않은 상태가 되면 그래프 실행이 종료된다.  
  
![img.png](image/img.png)  
  
랭그래프에서는 두 가지 유형의 그래프 클래스를 사용할 수 있다.  
  
- 상태 그래프(StateGraph): 일반적으로 사용하는 그래프 클래스다. 사용자가 정의하는 상태를 매개변수로 활용하며 다양한 워크플로우와 상태 관리를 
지원한다.  
- 메시지 그래프(MessageGraph): 오직 메시지 목록만으로 이루어지는 특별한 유형의 그래프 클래스다. 주로 챗봇과 같은 대화형 시스템에서 사용되며 메시지 
흐름을 단순화하여 관리하기에 적합하다.  
  
# **상태**  
그래프를 정의할 때 가장 먼저 해야 할 일은 그래프의 상태(state)를 정의하는 것이다. 상태란 애플리케이션 내에서 메시지로 주고받는 변수들의 집합이다. 
파이썬의 모든 타입으로 정의할 수 있지만 대체로 TypedDict나 Pydantic의 BaseModel 타입으로 선언한다. 상태는 그래프 내 모든 노드와 에지의 입력으로 
사용되며 각 노드의 상태를 업데이트할 수 있다.  
  
```
from typing import TypedDict

class State(TypedDict):
    count: int
    messages: list[str]  
```  
  
이 예시는 count와 messages라는 두 개의 필드를 갖는 상태 클래스다. 이 상태는 그래프 내 여러 노드에서 공유되며 지속적으로 업데이트된다.  
  
예를 들어 처음 노드에서 {"count": 1, "messages": ["hi"]}를 입력하고 다음 노드에서 {"count": 2}를 입력한다면 상태는 {"count": 2, "messages": ["hi"]}의 
형태가 된다. 그다음 노드에서 {"messages": ["bye"]}를 입력한다면 최종 상태는 {"count": 2, "messages": ["bye"]}의 형태가 된다.  
  
![img.png](image/img2.png)  
  
리듀서(reducer)를 사용한다면 기존 상태에 새로운 업데이트를 결합하여 새로운 상태를 생성하는것도 가능하다. 다음 예시와 같이 Annotated 타입으로 
리듀서 함수를 정의한다면 messages 변수는 리듀서 함수를 통해 업데이트된다.  
  
```
from typing import TypedDict, Annotated
from operator import add 

class State(TypedDict):
    count: int
    messages: Annotated[list[str], add]
```  
  
이 예시에서는 messages 필드에 add 리듀서가 지정되어 있어 새로운 메시지가 추가될 때 기존 리스트와 병합된다.  
  
예를 들어 처음 노드에서 {"count": 1, "messages": ["hi"]}를 입력하고 다음 노드에서 {"count": 2}를 입력한다면 상태는 {"count": 2, "messages": ["hi"]}의 
형태가 된다. 그다음 노드에서 {"messages": ["bye"]}를 입력한다면 최종 상태는 messages에 operator.add를 실행하여 {"count": 2, "messages": ["hi", "bye"]}의 형태가 된다.  
  
![img.png](image/img3.png)  
  
